MySQL索引事物
-- 索引和事物，未来面试必考的内容，出场频率极高
-- 关于数据库，面试中考啥
-- 1.给定场景写SQL（简单）
-- 2.数据库的索引（索引是干啥，索引的底层数据结构）
-- 3.数据库的事物（事物是干啥的，事物的特点，事物的隔离级别，不同隔离级别中产生的问题）
-- 4.其他内容（比较琐碎）

-- 涉及的SQL操作很少，也很简单，重点理解背后的原理（比较抽象，理解为主，背下来）





-- 索引(index):与书的目录一样，用于加快查找的效率(会影响插入、删除、修改的效率)
-- 如果数据库中没有索引，此时查找的时候就需要把整个表遍历一遍
-- 适用于一写多读的情况

SELECT * from student;
-- 如果想找id为8的学生，没有索引，此时的查找过程就相当于一个‘顺序表查找’
-- 如果是针对顺序表查找，顺序表是在内存中，内存访问速度多快，并且数据也没那么多，其实速度也还行
-- 如果是针对数据库顺序查找，数据库的数据是在磁盘上，磁盘访问速度更慢，并且数据量也可能非常多，这个速度可能就会很慢
-- 索引就是为了避免数据库进行顺序查找，提高查找效率

-- 索引可以考虑的数据结构
-- 1.二叉树（二叉搜索树），如果比较平衡，查找效率就是O(logN)
--        二叉搜索树内部元素是有序的（中序遍历结果是有序的）
--        例如查找 id<6 并且id>3的学生信息：先找到id为6的元素，再找到id为3的元素，中序遍历3和6之间的结果就是想要的结果
--        按照二叉搜索树典型的方式查找即可，效率：O(N)
-- 2.哈希表  查找效率是O(1)   哈希只能处理相等的情况，不能处理其他的逻辑 >  >=  <   <= , betwee and
--       数据可的索引可以考虑使用哈希，但是也有问题   例如：查找 id<6 并且id>3的学生信息
--       哈希查找过程：把key代入哈希函数，计算得到下标，再根据下标取得对应的链表，再去遍历比较key是否相等

-- 相比于哈希表，二叉搜索树虽然能处理范围查找，但是处理效率不高
-- 1.二叉搜索树每个节点做多两个叉，当数据量比较大的时候，树的高度就会比较高，最终的操作效率也 就会越低
-- 2.二叉搜索树直接获取到中序遍历也不是很高效O(N)


-- 真实的索引结构是一种N叉搜索树 => B+树
-- 要想认识B+树，需要先认识B树（也写作B-树）   B-:-为连接号，不是减号
-- 传统二叉树
--       7
--     /   \
--    4     10
--   / \      \
--  1   5      11
-- 如果索引数据很多，树的层次会很高（只有左右两个子节点），数据量大时查询还是会慢
-- 二叉树每个节点只存储一个记录，一次查询在树上找的时候花费磁盘IO次数较多
 
-- b树(N叉树)
                   15
          /                  \
        4   8            18       25      28
      /    /   \         /     \      \      \
    1 3  5 6  10 11 13  16 17  20 21  26 27  29 30 31

-- BTREE有以下特点：

    --   不再是二叉搜索，而是N叉搜索，树的高度会降低，查询快

    --   叶子节点，非叶子节点，都可以存储数据，且可以存储多个数据

    --   通过中序遍历，可以访问树上所有节点
    --   每个结点不是存一个数据了，而是可能存多个数据
    -- 每个节点的存的数据的个数和该节点的度是相关的： 度= 存的数据个数+1

--      4   8         4 和8把整个数据切分成3个部分   
--   /    /   \         
-- 1 3  5 6  10 11 13
--  |     |      |
-- 比4大   |    比8大
--       介于4与8之间        

--  1.此时在B树上查找，就是一个N分查找，效率比2分还快
--  2.由于每个节点存了多个数据，每个节点又有多个度，和二叉树相比，在保存相同个元素时，B树的高度就会比二叉树低很多
--  3.处理范围查找也更容易一些
-- 叶子，非叶子都是存储数据，都要放到磁盘上

-- B+树：真实的索引结构
--            | 14 |   | 55 |    |  87  |
--                  /
--                 /
--        | 14|   | 21|   |  48  |   |      非叶子节点只保存id，辅助快速找到想要的id对应的节点
--             /        /           \
--       |14 | 16|-> |21 | 31 | ->|48 | 50|        相当于这一行的id字段
--        数据 数据  数据  数据     数据 数据

-- B+TREE改进点及优势所在：

-- -      仍然是N叉树，层级小，非叶子节点不再存储数据，数据只存储在同一层的叶子节点上，B+树从根到每一个节点的路径长度一样，而B树不是这样

-- -      叶子之间，增加了链表(图中红色箭头指向)，获取所有节点，不再需要中序遍历，使用链表的next节点就可以快速访问到

-- -      范围查找方面，当定位min与max之后，中间叶子节点，就是结果集，不用中序回溯（范围查询在SQL中用得很多，这是B+树比B树最大的优势）

-- -      叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储

-- -     非叶子节点，不存储实际 记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引

-- 说B+树的时候，慎重黑B树
-- 不是B树不好，而是B树在MySQL这种关系型数据库中不是特别适用，但是在有些非关系型数据库(MongoDB),索引结构就是B树



-- 和B树相比，主要是两个地方发生变化
-- 1.每一层的元素之间都链接到一起了
-- 2.数据只在叶子结点上保存，非叶子节点上只保存一些辅助查找的边界信息
--     |
--   表中的一行记录

-- 查找任何一条记录速度是比较平均的，不会出现效率差异大的情况
-- 不需要进行额外的中序遍历了，遍历链表就是得到中序结果，处理范围查找就会更高效了
-- 叶子放到磁盘上，非叶子放到内存中，查找效率就更高了（减少了读磁盘的次数）
-- 索引在内存中占用的实际开销也不高


-- 索引起到的效果：加快查找效率，减慢插入和删除效率、修改效率（需要同步调整索引结构）
-- 索引也会占用额外的空间（本质上使用空间来换时间）
-- 给具体的表中某列加索引的时候，加载主键上的索引和加载其他列上的索引是截然不同的

-- 如果针对name来建立索引（不是主键）
--                 张三
--              /          \
--        李四   王五   丁六   蔡徐坤
--      /      |    \
--    李四   王五
--      1     2
--     主键id

-- 主键索引的叶子结点存的是数据的完整记录，其他索引的叶子节点存的是主键的id
-- 如果要是按照name查找，先通过索引找到‘王五’对应的主键id，再根据主键id去主键索引中查找到具体记录



-- 索引应用的场景主要是在查找频繁的场景中，但是插入，删除，修改都不频繁的场景
-- 以作业为例：每次布置作业，都相当于要进行查找，插入删除修改操作就非常少


-- 索引的使用
-- 创建主键约束（PRIMARY KEY）、唯一约束（UNIQUE）、外键约束（FOREIGN KEY）时，会自动创建对应列的索引。

-- 查看student表中的索引：show index from 表名;
show index from student;
-- +---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---
-- ----------+
-- | Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Co
-- x_comment |
-- +---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---
-- ----------+
-- | student |          0 | PRIMARY  |            1 | id          | A         |           8 |     NULL | NULL   |      | BTREE      |
--           |
-- +---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---
--     主键索引，针对id的索引，索引方式是BTREE


-- 创建索引：create index 索引名 on 表名(字段名);
create index index_name_student on student(name);
-- +---------+------------+--------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+
-- ----+---------------+ 
-- | Table   | Non_unique | Key_name           | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type |
-- ent | Index_comment |
-- +---------+------------+--------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+
-- ----+---------------+
-- | student |          0 | PRIMARY            |            1 | id          | A         |           8 |     NULL | NULL   |      | BTREE      |
--     |               |
-- | student |          1 | index_name_student |            1 | name        | A         |           8 |     NULL | NULL   | YES  | BTREE      |
--     |               |
-- +---------+------------+--------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+
-- id索引的叶子结点存的是整条记录；name索引的叶子节点存的是主键id


-- 删除索引：drop index 索引名 on 表名;
drop index index_name_student on student;
-- 主键索引不能删除

-- 创建索引和删除索引都是很耗时操作


-- 索引的重点：
-- 你了解索引吗？
-- 1.索引是什么
-- 2.索引要解决的问题
-- 3.索引的应用场景
-- 4.索引的数据结构
--    a.为什么不用哈希
--    b.为什么不用二叉搜索树
--    c.啥是B树，有啥优势
--    d.啥事B+树，有什么优势
-- 5.其他注意事项


-- explain
-- 帮助我们分析一个SQL的执行过程，能够看到是否使用索引，以及使用了哪个索引
--   key:NULL     <==key为null表示没有用到索引





-- 事务
--解决的问题：
--数据表，保存了一些人的银行账户余额，接下来需要进行的操作：A -> B转账3000块钱
--     分两个步骤：1.A的账户余额 -3000；   2.B的账户余额 +3000
-- 如果1执行成功了，执行2的时候出问题了，此时A的钱减少了，B的钱没有增加，此时3000块钱凭空消失了？

-- 什么是事务：把一座操作封装到一起：成为一个共同的执行单元。此时执行整个事务，就能避免上面的问题

-- 事务的基本特性（保证了能够解决刚才的问题）  ACID
-- 1.原子性（最重要的特点）：事务中的若干个操作，要么全部执行成功，要么就全都不执行。（并不是真的没执行，而是一旦中间某个步骤执行出错，就把前面已经执行完毕的步骤回滚（rollback）回去）
--                                                                                                                        回滚：借助逆向操作，把原来操作造成的影响进行还原。  例如：减3000 逆操作就是 加3000
-- 2.一致性：执行事务前后，数据始终处于一种合法的状态
--                  例如转账操作，减账户余额的时候，不能把账户减成负数
-- 3.持久性：事务一旦执行完毕，此时对于数据的修改就是持久生效的（写入磁盘了）
--                                             数据存到磁盘中就是持久的，数据存到内存中就是不持久的（重启就没了）
-- 4.隔离性（必考）：多个事物并发执行时，事物之间不能互相干扰（本质上就是线程安全问题）
--      隔离性和并发是相悖的（虽然两者是相悖的，但是在不同的场景下，对于数据准确性的要求不一样），就可以在满足数据准确要求的前提下尽可能的提高并发程度。   这就涉及到MySQL中的事物隔离级别
--          隔离是为了保证数据的准确，并发是为了提高事物执行的效率
--          如果多个事物之间隔离性越强，并发程度就越低，效率就越低
--          如果多个事务之间隔离性越弱，并发程度就越高，效率就越高
-- 隔离性：
-- 并发执行事物时，产生的问题：
-- 1.脏读
--       如果一个事物A正在修改数据（还没提交），另外一个事物B读取了这里的修改内容，此时这样的事物B的读操作就是脏读
--       因为事物A在提交数据之前，随时可能又修改刚才的数据
--       解决脏读的办法：给写操作加锁（A在修改数据过程中（提交之前），B尝试读，就会阻塞，一直阻塞到A提交数据之后，B才能读到数据）
--       引入写加锁，事物的并发程度就降低了，效率就低了，隔离性就提高了
--               写加锁：我写的时候，别人不能读
-- 2.不可重复读
--       一个事物A执行过程中，两次读取到的数据不相同，就叫做不可重复读
--       解决方案：读加锁
--       引入读加锁，事物的并发程度就更低了，效率也就更低了，隔离性就更高
--               读加锁：别人读的时候，我也不能写了

-- 3.幻读
--       一次事务执行过程中，多次读取到的结果集不一样（具体的结果数据是一致的），虽然读锁加了之后，读的时候不能改，但是可以新增或者删除记录
--       解决方案：串行化。（改的时候不能读，读的时候也不能改）
--       此时的并发程度最低，效率也最低。但是数据的可靠性最高 

-- MySQL的隔离级别:对隔离性的要求具体多高（隔离性高了，并发程度就低了，数据可靠性高了，效率就低了）
-- 1.read uncommitted:允许读取未提交的数据（隔离程度最低，并发性最高，会有脏读问题）
-- 2.read committed:只允许读取已经提交的数据，相当于写加锁（隔离性提高了一些，并发性降低了一些，解决了脏读，但是会有不可重复读）
-- 3.repeatable read(MySQL的默认级别)：给读也加锁（隔离性又提高了，并发性又降低了，解决了不可重复读，但是会有幻读问题）
-- 4.serializable:严格串行化执行（隔离性最高，并发最低，解决了幻读问题）

-- SQL语句中显示的指定当前的SQL使用哪种隔离级别，不指定，默认就是repeatable read
-- 此处只能结合具体业务来看。

-- 你对事物了解吗?谈谈你的理解
-- 1.事物是干啥的（解决啥问题）
-- 2.事物的概念
-- 3.事物的特性
-- 每个特性是干啥的，不要被概念（用自己的话来描述）
-- 重点介绍隔离性，介绍隔离性之前，先解释“并发”，可以涉及一些多线程的内容
-- 三个问题：脏读，不可重复读，幻读
-- mysql的隔离级别，以及隔离级别对应的上面的问题是啥




-- 事务的使用
-- （1）开启事务：start transaction;             -- 表示接下来的操作都在同一个事务中
-- （2）执行多条SQL语句                          -- 一旦中间出现失败，就会自动回滚
-- （3）回滚或提交：rollback/commit;             -- 事务结束，开始正式执行
-- 说明：rollback即是全部失败，commit即是全部成功。


